#include <iostream>
#include <fstream>
#include <ctime>
#include <math.h>
#include "main.h"
using namespace std;

sorting:: sorting (int n){
    N = n;
    arr = new int [N];
}
sorting:: ~sorting (){
    delete [] arr;
}
void sorting:: create_array(){
    ifstream f;
    f.open ("test_numbers.txt");
    for (int i=0; i<N; i++){
        f >> arr[i];
    }
    cout << "Создание массива без повторяющихся ключей на "<< N <<" элементов" << endl << endl;
}
void sorting:: reverse_array (){
    int temp;
    for (int i=0; i < N/2; i++){
        temp = arr[i];
        arr[i] = arr[N-1-i];
        arr[N-1-i] = temp;
    }
}
void sorting:: print_array (){
    for (int i=0; i<N; i++)
        cout << arr[i] << " ";
    cout << endl;
}

void sorting:: sort_on (){

    cout << "\tНеупорядоченный массив" << endl;
    cout << "Сортировка пузырьком" << endl;
    bubble(arr);
    create_array();

    cout << "Сортировка методом Шелла" << endl;
    ShellSort (arr);
    create_array();

    cout << "Сортировка методом Шелла (шаг задан числами Фибоначчи)" << endl;
    ShellSortFibonachi (arr);
    //create_array();

    //cout << "Поразрядная сортировка" << endl;

    cout << "\tУпорядоченный массив" << endl;
    cout << "Сортировка пузырьком" << endl;
    bubble(arr);

    cout << "Сортировка методом Шелла" << endl;
    ShellSort (arr);

    cout << "Сортировка методом Шелла (шаг задан числами Фибоначчи)" << endl;
    ShellSortFibonachi (arr);

    //cout << "Поразрядная сортировка" << endl;

    cout << "\tОбратно упорядоченный массив" << endl;
    cout << "Сортировка пузырьком" << endl;
    reverse_array();
    print_array();
    bubble(arr);

    cout << "Сортировка методом Шелла" << endl;
    reverse_array();
    ShellSort (arr);

    cout << "Сортировка методом Шелла (шаг задан числами Фибоначчи)" << endl;
    reverse_array();
    ShellSortFibonachi (arr);

    //cout << "Поразрядная сортировка" << endl;
}
void sorting:: bubble(int *a)      //сортировка пузырьком
{
	long long int main_count =0, extra_count = 0;
    clock_t  t0, t;
    t0 = clock();
	int tmp, i, j;

	for (i = 1,++extra_count; i < N; i++, ++extra_count){
		for (j = N-1, ++extra_count; j >= i;  ++extra_count, j--){
			if (a[j-1] > a[j]){    //отсортируем по возрастанию
				tmp = a[j-1];    main_count++;
				a[j-1] = a[j]; main_count++;
				a[j] = tmp;      main_count++;
			}
		}
	}

    t = clock();
	cout << "\tКоличество основных присваиваний: " << main_count << endl;
	cout << "\tКоличество вспомогательных присваиваний: " << extra_count << endl;
	cout << "\tВремя работы алгоритма: " << double(t-t0)/CLOCKS_PER_SEC << endl;
}
void sorting:: ShellSort (int *a)     //сортировка Шелла
{
    long long main_count =0, extra_count = 0;
    clock_t t0, t1;
    t0 = clock();

    const int t=(int)(log(N)/log(2)-1);extra_count++;
    int i, j, k, m, x;
    int *h = (int *) malloc (t*sizeof(int));

    h[t-1] = 1; extra_count++;
    for (m=t-2, extra_count++; m>=0; m--, extra_count++)
    {
        h[m]= h[m+1] * 2 + 1;   extra_count++;
    }
    for (m=0, extra_count++; m<t; m++,     extra_count++)                                 //последовательно перебираем все расстояния
    {
        k = h[m];   extra_count++;
        for (i=k, extra_count++; i<N; i++, extra_count++)                             //до конца цикла метод вставки с учетом шага h[m]
        {
            x = a[i];   main_count++;
            j = i-k;    extra_count++;
            while (j>=0 && x<a[j])
            {
                a[j+k]=a[j];    main_count++;
                j -= k;         extra_count++;
            }
            a[j+k] = x;         main_count++;
        }
    }
    free (h);
    t1 = clock();
	cout << "Количество основных присваиваний: " << main_count << endl;
	cout << "Количество вспомогательных присваиваний: " << extra_count << endl;
	cout << "Время работы алгоритма: " << double(t1-t0)/CLOCKS_PER_SEC << endl;
}
void sorting:: ShellSortFibonachi (int *a)     //сортировка Шелла (шаг задается числами фибоначчи)
{
    long long main_count =0, extra_count = 0;
    clock_t t0, t1;
    t0 = clock();

    int t = 0;
    for (int i = 1, j = 1; i < N / 2; t++){
        i = i + j;
        j = i - j;
    }
    int i, j, k, m, x;
    int *h = (int *) malloc (t*sizeof(int));
    h[t-1] = 1; extra_count++;
    h[t-2] = 2; extra_count++;

    for (m=t-2, extra_count++; m>=1; m--, extra_count++)
    {
        h[m-1]= h[m] + h[m+1];   extra_count++;
    }
    for (m=0, extra_count++; m<t; m++,extra_count++)                                 //последовательно перебираем все расстояния
    {
        k = h[m];   extra_count++;
        for (i=k, extra_count++; i<N; i++, extra_count++)                             //до конца цикла метод вставки с учетом шага h[m]
        {
            x = a[i];   main_count++;
            j = i-k;    extra_count++;
            while (j>=0 && x<a[j])
            {
                a[j+k]=a[j];    main_count++;
                j -= k;         extra_count++;
            }
            a[j+k] = x;         main_count++;
        }
    }
    free (h);

    t1 = clock();
	cout << "Количество основных присваиваний: " << main_count << endl;
	cout << "Количество вспомогательных присваиваний: "<< extra_count << endl;
    cout << "Время работы алгоритма: " << double (t1-t0)/CLOCKS_PER_SEC << endl;
}
/* поразрядная сортировка

typedef unsigned char uchar;
typedef unsigned short int ushort;

long long main_count =0, extra_count = 0;

void swap(int& a, int& b)
{
    int tmp = a;
    a = b;
    b = tmp;
    extra_count += 3;
}

// Создать счетчики.
// data-сортируемый массив, counters-массив для счетчиков, N-число элементов в data

void createCounters(int* data, long* counters, long N) {
    // i-й массив count расположен, начиная с адреса counters+256*i
    memset(counters, 0, 256 * sizeof(int) * sizeof(long));

    uchar* bp = (uchar*)data;
    uchar* dataEnd = (uchar*)(data + N);
    ushort i;

    while (bp != dataEnd) {
        // увеличиваем количество байт со значением *bp
        // i - текущий массив счетчиков
        for (i = 0; i < sizeof(int); i++) {
            counters[256 * i + *bp++]++;
        }
    }
}

// Функция radixPass принимает в качестве параметров
// номер байта Offset,
// число элементов N,
// исходный массив source,
// массив dest, куда будут записываться числа, отсортированные по байту Offset
// массив счетчиков count, соответствующий текущему проходу.

void radixPass(short Offset, long N, int* source, int* dest, long* count) {
    // временные переменные
    int* sp;
    long s, c, i, * cp;
    uchar* bp;


    // шаг 3
    s = 0, extra_count++; 	// временная переменная, хранящая сумму на данный момент
    cp = count, extra_count++;
    int cou = 0;
    for (++extra_count, i = 256; i > 0; extra_count += 2, --i, ++cp) {
        c = *cp;
        *cp = s;
        s += c;
        ++main_count;
        extra_count += 2;
        cou++;
    }

    cou = 0;
    // шаг 4
    bp = (uchar*)source + Offset;
    extra_count += 1;
    sp = source;
    extra_count += 1;
    for (extra_count++, i = N; i > 0; --i, bp += sizeof(int), ++sp, extra_count += 3) {
        cp = count + *bp;
        dest[*cp] = *sp;
        ++(*cp);
        main_count++;
        extra_count += 2;

        cou++;
    }
}

// сортируется массив in из N элементов
// T - любой беззнаковый целый тип

// проход поразрядной сортировки по старшим байтам,
// для целых чисел со знаком Offset = sizeof(T)-1.

void signedRadixLastPass(short Offset, long N, int* source, int* dest, long* count) {
    int* sp;
    long s, c, i, * cp;
    uchar* bp;

    // подсчет количества отрицательных чисел
    long numNeg = 0;
    for (i = 128, extra_count += 1; i < 256; i++, extra_count+= 1) {
        extra_count += 1;
        numNeg += count[i];
    }

    // первые 128 элементов count относятся к положительным числам.
    // отсчитываем номер первого числа, начиная от numNeg
    s = numNeg;
    cp = count;
    extra_count += 2;
    for (extra_count+= 1,i = 0; i < 128; extra_count += 1, ++i, extra_count += 1, ++cp) {
        c = *cp;
        *cp = s;
        s += c;
       main_count += 1;
        extra_count += 2;
    }

    // номера для отрицательных чисел отсчитываем от начала массива
    s = 0;
    cp = count + 128;
    extra_count += 2;
    for (extra_count += 1, i = 0; i < 128; extra_count += 1, ++i, extra_count += 1, ++cp) {
        c = *cp;
        *cp = s;
        s += c;
        main_count += 1;
        extra_count += 2;
    }


    bp = (uchar*)source + Offset;
    sp = source;
    extra_count += 2;
    for (extra_count += 1, i = N; i > 0; --i, extra_count += 1, bp += sizeof(int), extra_count += 1, ++sp) {
        cp = count + *bp;
        dest[*cp] = *sp;
        ++(*cp);
        main_count += 1;
        extra_count += 2;
    }
}

void signedRadixSort(int* a) {
    clock_t t0, t;
    t0 = clock();
    int* out = new int[N];
    ushort i;

    long* counters = new long[sizeof(int) * 256], * count;

    createCounters(a, counters, N);

    for (++extra_count, i = 0; i < sizeof(int) - 1; ++extra_count, i++) {
        count = counters + 256 * i, ++extra_count;
        if (count[0] == N) continue;
        radixPass(i, N, a, out, count);
        swap(a, out);
    }
    count = counters + 256 * i;
    extra_count += 1;
    signedRadixLastPass(i, N, a, out, count);
    swap(a, out);

    a = out;
    delete[] counters;

    t = clock();
	cout << "Количество основных присваиваний: " << main_count << endl;
	cout << "Количество вспомогательных присваиваний: "<< extra_count << endl;
    cout << "Время работы алгоритма: " << double (t-t0)/CLOCKS_PER_SEC << endl;
}*/


